{"version":3,"file":"hotwire_spark.min.js","sources":["../../../node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js","../../javascript/hotwire/spark/channels/consumer.js","../../javascript/hotwire/spark/helpers.js","../../../node_modules/idiomorph/dist/idiomorph.esm.js","../../javascript/hotwire/spark/logger.js","../../javascript/hotwire/spark/reloaders/stimulus_reloader.js","../../javascript/hotwire/spark/reloaders/morph_html_reloader.js","../../javascript/hotwire/spark/reloaders/css_reloader.js","../../javascript/hotwire/spark/reloaders/replace_html_reloader.js","../../javascript/hotwire/spark/channels/monitoring_channel.js","../../javascript/hotwire/spark/index.js"],"sourcesContent":["var adapters = {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined\n};\n\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\n\nconst now = () => (new Date).getTime();\n\nconst secondsSince = time => (now() - time) / 1e3;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordMessage() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout((() => {\n      this.reconnectIfStale();\n      this.poll();\n    }), this.getPollInterval());\n  }\n  getPollInterval() {\n    const {staleThreshold: staleThreshold, reconnectionBackoffRate: reconnectionBackoffRate} = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout((() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }), 200);\n    }\n  }\n}\n\nConnectionMonitor.staleThreshold = 6;\n\nConnectionMonitor.reconnectionBackoffRate = .15;\n\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\",\n    remote: \"remote\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [ \"actioncable-v1-json\", \"actioncable-unsupported\" ]\n};\n\nconst {message_types: message_types, protocols: protocols} = INTERNAL;\n\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\n\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [ ...protocols, ...this.consumer.subprotocols || [] ];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close({allowReconnect: allowReconnect} = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {};\n    }\n  }\n}\n\nConnection.reopenDelay = 500;\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {identifier: identifier, message: message, reason: reason, reconnect: reconnect, type: type} = JSON.parse(event.data);\n    this.monitor.recordMessage();\n    switch (type) {\n     case message_types.welcome:\n      if (this.triedToReconnect()) {\n        this.reconnectAttempted = true;\n      }\n      this.monitor.recordConnect();\n      return this.subscriptions.reload();\n\n     case message_types.disconnect:\n      logger.log(`Disconnecting. Reason: ${reason}`);\n      return this.close({\n        allowReconnect: reconnect\n      });\n\n     case message_types.ping:\n      return null;\n\n     case message_types.confirmation:\n      this.subscriptions.confirmSubscription(identifier);\n      if (this.reconnectAttempted) {\n        this.reconnectAttempted = false;\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: true\n        });\n      } else {\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: false\n        });\n      }\n\n     case message_types.rejection:\n      return this.subscriptions.reject(identifier);\n\n     default:\n      return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\n\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter((s => s !== subscription));\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout((() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map((subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        }));\n      }\n    }), 500);\n  }\n}\n\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    }));\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter((s => s !== subscription));\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter((s => s.identifier === identifier));\n  }\n  reload() {\n    return this.subscriptions.map((subscription => this.subscribe(subscription)));\n  }\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription => this.notify(subscription, callbackName, ...args)));\n  }\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [ subscription ];\n    }\n    return subscriptions.map((subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined));\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map((subscription => this.guarantor.forget(subscription)));\n  }\n  sendCommand(subscription, command) {\n    const {identifier: identifier} = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\n\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [ ...this.subprotocols, subprotocol ];\n  }\n}\n\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\n\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\n\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };\n","import { createConsumer } from \"@rails/actioncable\"\n\nexport default createConsumer(\"/hotwire-spark\")\n","export function assetNameFromPath(path) {\n  return path.split(\"/\").pop().split(\".\")[0]\n}\n\nexport function pathWithoutAssetDigest(path) {\n  return path.replace(/-[a-z0-9]+\\.(\\w+)(\\?.*)?$/, \".$1\")\n}\n\nexport function urlWithParams(urlString, params) {\n  const url = new URL(urlString, window.location.origin)\n  Object.entries(params).forEach(([ key, value ]) => {\n    url.searchParams.set(key, value)\n  })\n  return url.toString()\n}\n\nexport function cacheBustedUrl(urlString) {\n  return urlWithParams(urlString, { reload: Date.now() })\n}\n\nexport async function reloadHtmlDocument() {\n  let currentUrl = cacheBustedUrl(urlWithParams(window.location.href, { hotwire_spark: \"true\" }))\n  const response = await fetch(currentUrl, { headers: { \"Accept\": \"text/html\" }})\n\n  if (!response.ok) {\n    throw new Error(`${response.status} when fetching ${currentUrl}`)\n  }\n\n  const fetchedHTML = await response.text()\n  const parser = new DOMParser()\n  return parser.parseFromString(fetchedHTML, \"text/html\")\n}\n\nexport function getConfigurationProperty(name) {\n  return document.querySelector(`meta[name=\"hotwire-spark:${name}\"]`)?.content\n}\n\n","// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n                    if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                        to.setAttribute(fromAttribute.name, fromAttribute.value);\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n","import HotwireSpark from \"./index.js\"\n\nexport function log(...args) {\n  if (HotwireSpark.config.loggingEnabled) {\n    console.log(`[hotwire_spark]`, ...args)\n  }\n}\n\n","import { log } from \"../logger.js\"\nimport { cacheBustedUrl, reloadHtmlDocument } from \"../helpers.js\"\n\nexport class StimulusReloader {\n  static async reload(changedFilePath) {\n    const document = await reloadHtmlDocument()\n    return new StimulusReloader(document, changedFilePath).reload()\n  }\n\n  static async reloadAll() {\n    Stimulus.controllers.forEach(controller => {\n      Stimulus.unload(controller.identifier)\n      Stimulus.register(controller.identifier, controller.constructor)\n    })\n\n    return Promise.resolve()\n  }\n\n  constructor(document, changedFilePath) {\n    this.document = document\n    this.changedFilePath = changedFilePath\n    this.application = window.Stimulus\n  }\n\n  async reload() {\n    log(\"Reload Stimulus controllers...\")\n\n    this.application.stop()\n\n    await this.#reloadChangedStimulusControllers()\n    this.#unloadDeletedStimulusControllers()\n\n    this.application.start()\n  }\n\n  async #reloadChangedStimulusControllers() {\n    await Promise.all(\n      this.#stimulusControllerPathsToReload.map(async moduleName => this.#reloadStimulusController(moduleName))\n    )\n  }\n\n  get #stimulusControllerPathsToReload() {\n    this.controllerPathsToReload = this.controllerPathsToReload || this.#stimulusControllerPaths.filter(path => this.#shouldReloadController(path))\n    return this.controllerPathsToReload\n  }\n\n  get #stimulusControllerPaths() {\n    return Object.keys(this.#stimulusPathsByModule).filter(path => path.endsWith(\"_controller\"))\n  }\n\n  #shouldReloadController(path) {\n    return this.#extractControllerName(path) === this.#changedControllerIdentifier\n  }\n\n  get #changedControllerIdentifier() {\n    this.changedControllerIdentifier = this.changedControllerIdentifier || this.#extractControllerName(this.changedFilePath)\n    return this.changedControllerIdentifier\n  }\n\n  get #stimulusPathsByModule() {\n    this.pathsByModule = this.pathsByModule || this.#parseImportmapJson()\n    return this.pathsByModule\n  }\n\n  #parseImportmapJson() {\n    const importmapScript = this.document.querySelector(\"script[type=importmap]\")\n    return JSON.parse(importmapScript.text).imports\n  }\n\n  async #reloadStimulusController(moduleName) {\n    log(`\\t${moduleName}`)\n\n    const controllerName = this.#extractControllerName(moduleName)\n    const path = cacheBustedUrl(this.#pathForModuleName(moduleName))\n\n    const module = await import(path)\n\n    this.#registerController(controllerName, module)\n  }\n\n  #unloadDeletedStimulusControllers() {\n    this.#controllersToUnload.forEach(controller => this.#deregisterController(controller.identifier))\n  }\n\n  get #controllersToUnload() {\n    if (this.#didChangeTriggerAReload) {\n      return []\n    } else {\n      return this.application.controllers.filter(controller => this.#changedControllerIdentifier === controller.identifier)\n    }\n  }\n\n  get #didChangeTriggerAReload() {\n    return this.#stimulusControllerPathsToReload.length > 0\n  }\n\n  #pathForModuleName(moduleName) {\n    return this.#stimulusPathsByModule[moduleName]\n  }\n\n  #extractControllerName(path) {\n    return path\n      .replace(/^\\/+/, \"\")\n      .replace(/^controllers\\//, \"\")\n      .replace(\"_controller\", \"\")\n      .replace(/\\//g, \"--\")\n      .replace(/_/g, \"-\")\n      .replace(/\\.js$/, \"\")\n  }\n\n  #registerController(name, module) {\n    this.application.unload(name)\n    this.application.register(name, module.default)\n  }\n\n  #deregisterController(name) {\n    log(`\\tRemoving controller ${name}`)\n    this.application.unload(name)\n  }\n}\n","import { Idiomorph } from \"idiomorph/dist/idiomorph.esm.js\"\nimport { reloadHtmlDocument } from \"../helpers.js\"\nimport { log } from \"../logger.js\"\nimport { StimulusReloader } from \"./stimulus_reloader.js\"\n\nexport class MorphHtmlReloader {\n  static async reload() {\n    return new MorphHtmlReloader().reload()\n  }\n\n  async reload() {\n    await this.#reloadHtml()\n    await this.#reloadStimulus()\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with morph...\")\n\n    const reloadedDocument = await reloadHtmlDocument()\n    this.#updateBody(reloadedDocument.body)\n    return reloadedDocument\n  }\n\n  #updateBody(newBody) {\n    Idiomorph.morph(document.body, newBody)\n  }\n\n  async #reloadStimulus() {\n    await StimulusReloader.reloadAll()\n  }\n}\n","import { log } from \"../logger.js\"\nimport { cacheBustedUrl, reloadHtmlDocument, pathWithoutAssetDigest } from \"../helpers.js\"\n\nexport class CssReloader {\n  static async reload(...params) {\n    return new CssReloader(...params).reload()\n  }\n\n  constructor(filePattern = /./) {\n    this.filePattern = filePattern\n  }\n\n  async reload() {\n    log(\"Reload css...\")\n    await Promise.all(await this.#reloadAllLinks())\n  }\n\n  async #reloadAllLinks() {\n    const cssLinks = await this.#loadNewCssLinks();\n    return cssLinks.map(link => this.#reloadLinkIfNeeded(link))\n  }\n\n  async #loadNewCssLinks() {\n    const reloadedDocument = await reloadHtmlDocument()\n    return Array.from(reloadedDocument.head.querySelectorAll(\"link[rel='stylesheet']\"))\n  }\n\n  #reloadLinkIfNeeded(link) {\n    if (this.#shouldReloadLink(link)) {\n      return this.#reloadLink(link)\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  #shouldReloadLink(link) {\n    return this.filePattern.test(link.getAttribute(\"href\"))\n  }\n\n  async #reloadLink(link) {\n    return new Promise(resolve => {\n      const href = link.getAttribute(\"href\")\n      const newLink = this.#findExistingLinkFor(link) || this.#appendNewLink(link)\n\n      newLink.setAttribute(\"href\", cacheBustedUrl(link.getAttribute(\"href\")))\n      newLink.onload = () => {\n        log(`\\t${href}`)\n        resolve()\n      }\n    })\n  }\n\n  #findExistingLinkFor(link) {\n    return this.#cssLinks.find(newLink => pathWithoutAssetDigest(link.href) === pathWithoutAssetDigest(newLink.href))\n  }\n\n  get #cssLinks() {\n    return Array.from(document.querySelectorAll(\"link[rel='stylesheet']\"))\n  }\n\n  #appendNewLink(link) {\n    document.head.append(link)\n    return link\n  }\n}\n","import { log } from \"../logger.js\"\n\nexport class ReplaceHtmlReloader {\n  static async reload() {\n    return new ReplaceHtmlReloader().reload()\n  }\n\n  async reload() {\n    await this.#reloadHtml()\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with Turbo...\")\n\n    this.#keepScrollPosition()\n    await this.#visitCurrentPage()\n  }\n\n  #keepScrollPosition() {\n    document.addEventListener(\"turbo:before-render\", () => {\n      Turbo.navigator.currentVisit.scrolled = true\n    }, { once: true })\n  }\n\n  #visitCurrentPage() {\n    return new Promise(resolve => {\n      document.addEventListener(\"turbo:load\", () => resolve(document), { once: true })\n      window.Turbo.visit(window.location)\n    })\n  }\n}\n","import consumer from \"./consumer\"\nimport { assetNameFromPath } from \"../helpers.js\";\nimport { MorphHtmlReloader } from \"../reloaders/morph_html_reloader.js\";\nimport { CssReloader } from \"../reloaders/css_reloader.js\";\nimport { StimulusReloader } from \"../reloaders/stimulus_reloader.js\";\nimport { ReplaceHtmlReloader } from \"../reloaders/replace_html_reloader.js\";\n\nconsumer.subscriptions.create({ channel: \"Hotwire::Spark::Channel\" }, {\n  connected() {\n    document.body.setAttribute(\"data-hotwire-spark-ready\", \"\")\n  },\n\n  async received(message) {\n    try {\n      await this.dispatch(message)\n    } catch(error) {\n      console.log(`Error on ${message.action}`, error)\n    }\n  },\n\n  dispatch({ action, path }) {\n    switch(action) {\n      case \"reload_html\":\n        return this.reloadHtml()\n      case \"reload_css\":\n        return this.reloadCss(path)\n      case \"reload_stimulus\":\n        return this.reloadStimulus(path)\n      default:\n        throw new Error(`Unknown action: ${action}`)\n    }\n  },\n\n  reloadHtml() {\n    const htmlReloader = HotwireSpark.config.htmlReloadMethod == \"morph\" ? MorphHtmlReloader : ReplaceHtmlReloader\n    return htmlReloader.reload()\n  },\n\n  reloadCss(path) {\n    const fileName = assetNameFromPath(path)\n    return CssReloader.reload(new RegExp(fileName))\n  },\n\n  reloadStimulus(path) {\n    return StimulusReloader.reload(path)\n  }\n})\n\n","import \"./channels/monitoring_channel.js\"\nimport { getConfigurationProperty } from \"./helpers.js\";\n\nconst HotwireSpark = {\n  config: {\n    loggingEnabled: false,\n    htmlReloadMethod: \"morph\"\n  }\n}\n\nconst configProperties = {\n  loggingEnabled: \"logging\",\n  htmlReloadMethod: \"html-reload-method\",\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  Object.entries(configProperties).forEach(([key, property]) => {\n    HotwireSpark.config[key] = getConfigurationProperty(property)\n  })\n})\n\nexport default HotwireSpark\n"],"names":["adapters","logger","console","undefined","WebSocket","log","messages","this","enabled","push","Date","now","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","staleThreshold","stop","stopPolling","removeEventListener","recordMessage","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","reconnectionBackoffRate","Math","pow","min","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","document","visibilityState","isOpen","INTERNAL","message_types","welcome","disconnect","ping","confirmation","rejection","disconnect_reasons","unauthorized","invalid_request","server_restart","remote","default_mount_path","protocols","supportedProtocols","slice","length","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","socketProtocols","subprotocols","uninstallEventHandlers","url","installEventHandlers","close","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","triedToReconnect","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","identifier","reason","reconnect","type","parse","reconnectAttempted","reload","confirmSubscription","notify","reconnected","reject","notifyAll","willAttemptReconnect","Subscription","params","mixin","object","properties","key","value","extend","perform","action","command","unsubscribe","remove","SubscriptionGuarantor","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","Subscriptions","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","Consumer","_url","test","a","createElement","href","replace","createWebSocketURL","connect","addSubProtocol","subprotocol","createConsumer","name","element","head","querySelector","getAttribute","getConfig","pathWithoutAssetDigest","path","urlWithParams","urlString","URL","window","location","origin","Object","entries","forEach","_ref","searchParams","set","toString","cacheBustedUrl","async","reloadHtmlDocument","currentUrl","hotwire_spark","response","fetch","headers","Accept","ok","Error","status","fetchedHTML","text","DOMParser","parseFromString","Idiomorph","EMPTY_SET","Set","defaults","morphStyle","callbacks","beforeNodeAdded","noOp","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","style","shouldPreserve","elt","shouldReAppend","shouldRemove","afterHeadMorphed","morphNormalizedContent","oldNode","normalizedNewContent","ctx","block","oldHead","newHead","promises","handleHeadElement","Promise","all","then","assign","ignore","morphChildren","children","bestMatch","newContent","currentElement","firstChild","bestElement","score","newScore","scoreElement","nextSibling","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","stack","added","node","pop","parentElement","insertBefore","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","ignoreActiveValue","activeElement","ignoreActive","isSoftMatch","HTMLHeadElement","from","to","nodeType","fromAttributes","attributes","toAttributes","fromAttribute","ignoreAttribute","setAttribute","i","toAttribute","hasAttribute","removeAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","syncNodeFrom","replaceChild","newParent","oldParent","newChild","nextNewChild","insertionPoint","appendChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","attr","updateType","attributeName","ignoreUpdate","newHeadTag","currentHead","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","outerHTML","currentHeadElt","inNewContent","has","isReAppended","isPreserved","delete","values","newNode","newElt","createRange","createContextualFragment","src","resolve","promise","_resolve","removedElement","removeChild","kept","node1","node2","tagName","id","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","isIdInConsideration","deadIds","idIsWithinNode","targetNode","idMap","get","idSet","sourceSet","matchCount","populateIdMapForNode","nodeParent","idElements","querySelectorAll","current","createIdMap","oldContent","morph","config","Document","documentElement","parser","contentWithSvgsRemoved","match","content","generatedByIdiomorph","htmlElement","body","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","finalConfig","mergeDefaults","target","createMorphContext","HotwireSpark","loggingEnabled","_len","arguments","Array","_key","StimulusReloader","changedFilePath","reloadAll","Stimulus","controllers","controller","unload","register","application","reloadChangedStimulusControllers","unloadDeletedStimulusControllers","stimulusControllerPathsToReload","reloadStimulusController","moduleName","controllerPathsToReload","stimulusControllerPaths","shouldReloadController","keys","stimulusPathsByModule","endsWith","extractControllerName","changedControllerIdentifier","pathsByModule","parseImportmapJson","importmapScript","imports","controllerName","pathForModuleName","module","import","registerController","controllersToUnload","deregisterController","didChangeTriggerAReload","default","MorphHtmlReloader","reloadHtml","reloadStimulus","reloadedDocument","updateBody","newBody","CssReloader","filePattern","reloadAllLinks","loadNewCssLinks","link","reloadLinkIfNeeded","shouldReloadLink","reloadLink","newLink","findExistingLinkFor","appendNewLink","onload","cssLinks","find","ReplaceHtmlReloader","keepScrollPosition","visitCurrentPage","Turbo","navigator","currentVisit","scrolled","once","visit","connected","received","dispatch","reloadCss","htmlReloadMethod","fileName","split","assetNameFromPath","RegExp","configProperties","property"],"mappings":"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","x_google_ignoreList":[0,3]}