{"version":3,"file":"hotwire_spark.min.js","sources":["../../javascript/hotwire/spark/config.js","../../../node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js","../../javascript/hotwire/spark/channels/consumer.js","../../javascript/hotwire/spark/helpers.js","../../../node_modules/idiomorph/dist/idiomorph.esm.js","../../javascript/hotwire/spark/logger.js","../../javascript/hotwire/spark/reloaders/stimulus_reloader.js","../../javascript/hotwire/spark/reloaders/morph_html_reloader.js","../../javascript/hotwire/spark/reloaders/css_reloader.js","../../javascript/hotwire/spark/reloaders/replace_html_reloader.js","../../javascript/hotwire/spark/channels/monitoring_channel.js","../../javascript/hotwire/spark/index.js"],"sourcesContent":["function getConfigurationProperty(name) {\n  return document.querySelector(`meta[name=\"hotwire-spark:${name}\"]`)?.content\n}\n\nexport default {\n  loggingEnabled: getConfigurationProperty(\"logging\") ?? false,\n  htmlReloadMethod: getConfigurationProperty(\"html-reload-method\"),\n  cableServerPath: getConfigurationProperty(\"cable-server-path\"),\n}\n","var adapters = {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined\n};\n\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\n\nconst now = () => (new Date).getTime();\n\nconst secondsSince = time => (now() - time) / 1e3;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordMessage() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout((() => {\n      this.reconnectIfStale();\n      this.poll();\n    }), this.getPollInterval());\n  }\n  getPollInterval() {\n    const {staleThreshold: staleThreshold, reconnectionBackoffRate: reconnectionBackoffRate} = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout((() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }), 200);\n    }\n  }\n}\n\nConnectionMonitor.staleThreshold = 6;\n\nConnectionMonitor.reconnectionBackoffRate = .15;\n\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\",\n    remote: \"remote\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [ \"actioncable-v1-json\", \"actioncable-unsupported\" ]\n};\n\nconst {message_types: message_types, protocols: protocols} = INTERNAL;\n\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\n\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [ ...protocols, ...this.consumer.subprotocols || [] ];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close({allowReconnect: allowReconnect} = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {};\n    }\n  }\n}\n\nConnection.reopenDelay = 500;\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {identifier: identifier, message: message, reason: reason, reconnect: reconnect, type: type} = JSON.parse(event.data);\n    this.monitor.recordMessage();\n    switch (type) {\n     case message_types.welcome:\n      if (this.triedToReconnect()) {\n        this.reconnectAttempted = true;\n      }\n      this.monitor.recordConnect();\n      return this.subscriptions.reload();\n\n     case message_types.disconnect:\n      logger.log(`Disconnecting. Reason: ${reason}`);\n      return this.close({\n        allowReconnect: reconnect\n      });\n\n     case message_types.ping:\n      return null;\n\n     case message_types.confirmation:\n      this.subscriptions.confirmSubscription(identifier);\n      if (this.reconnectAttempted) {\n        this.reconnectAttempted = false;\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: true\n        });\n      } else {\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: false\n        });\n      }\n\n     case message_types.rejection:\n      return this.subscriptions.reject(identifier);\n\n     default:\n      return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\n\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter((s => s !== subscription));\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout((() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map((subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        }));\n      }\n    }), 500);\n  }\n}\n\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    }));\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter((s => s !== subscription));\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter((s => s.identifier === identifier));\n  }\n  reload() {\n    return this.subscriptions.map((subscription => this.subscribe(subscription)));\n  }\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription => this.notify(subscription, callbackName, ...args)));\n  }\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [ subscription ];\n    }\n    return subscriptions.map((subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined));\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map((subscription => this.guarantor.forget(subscription)));\n  }\n  sendCommand(subscription, command) {\n    const {identifier: identifier} = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\n\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [ ...this.subprotocols, subprotocol ];\n  }\n}\n\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\n\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\n\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };\n","import { createConsumer } from \"@rails/actioncable\"\nimport config from \"../config\"\n\nexport default createConsumer(config.cableServerPath)\n","export function assetNameFromPath(path) {\n  return path.split(\"/\").pop().split(\".\")[0]\n}\n\nexport function pathWithoutAssetDigest(path) {\n  return path.replace(/-[a-z0-9]+\\.(\\w+)(\\?.*)?$/, \".$1\")\n}\n\nexport function urlWithParams(urlString, params) {\n  const url = new URL(urlString, window.location.origin)\n  Object.entries(params).forEach(([ key, value ]) => {\n    url.searchParams.set(key, value)\n  })\n  return url.toString()\n}\n\nexport function cacheBustedUrl(urlString) {\n  return urlWithParams(urlString, { reload: Date.now() })\n}\n\nexport async function reloadHtmlDocument() {\n  let currentUrl = cacheBustedUrl(urlWithParams(window.location.href, { hotwire_spark: \"true\" }))\n  const response = await fetch(currentUrl, { headers: { \"Accept\": \"text/html\" }})\n\n  if (!response.ok) {\n    throw new Error(`${response.status} when fetching ${currentUrl}`)\n  }\n\n  const fetchedHTML = await response.text()\n  const parser = new DOMParser()\n  return parser.parseFromString(fetchedHTML, \"text/html\")\n}\n","// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n                    if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                        to.setAttribute(fromAttribute.name, fromAttribute.value);\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n","import config from \"./config\"\n\nexport const LOG_TAG = \"[hotwire_spark]\";\n\nexport function log(...args) {\n  if (config.loggingEnabled) {\n    console.log(LOG_TAG, ...args)\n  }\n}\n\n","import { log } from \"../logger.js\"\nimport { cacheBustedUrl, reloadHtmlDocument } from \"../helpers.js\"\n\nexport class StimulusReloader {\n  static async reload(changedFilePath) {\n    const document = await reloadHtmlDocument()\n    return new StimulusReloader(document, changedFilePath).reload()\n  }\n\n  static async reloadAll() {\n    Stimulus.controllers.forEach(controller => {\n      Stimulus.unload(controller.identifier)\n      Stimulus.register(controller.identifier, controller.constructor)\n    })\n\n    return Promise.resolve()\n  }\n\n  constructor(document, changedFilePath) {\n    this.document = document\n    this.changedFilePath = changedFilePath\n    this.application = window.Stimulus\n  }\n\n  async reload() {\n    log(\"Reload Stimulus controllers...\")\n\n    this.application.stop()\n\n    await this.#reloadChangedStimulusControllers()\n    this.#unloadDeletedStimulusControllers()\n\n    this.application.start()\n  }\n\n  async #reloadChangedStimulusControllers() {\n    await Promise.all(\n      this.#stimulusControllerPathsToReload.map(async moduleName => this.#reloadStimulusController(moduleName))\n    )\n  }\n\n  get #stimulusControllerPathsToReload() {\n    this.controllerPathsToReload = this.controllerPathsToReload || this.#stimulusControllerPaths.filter(path => this.#shouldReloadController(path))\n    return this.controllerPathsToReload\n  }\n\n  get #stimulusControllerPaths() {\n    return Object.keys(this.#stimulusPathsByModule).filter(path => path.endsWith(\"_controller\"))\n  }\n\n  #shouldReloadController(path) {\n    return this.#extractControllerName(path) === this.#changedControllerIdentifier\n  }\n\n  get #changedControllerIdentifier() {\n    this.changedControllerIdentifier = this.changedControllerIdentifier || this.#extractControllerName(this.changedFilePath)\n    return this.changedControllerIdentifier\n  }\n\n  get #stimulusPathsByModule() {\n    this.pathsByModule = this.pathsByModule || this.#parseImportmapJson()\n    return this.pathsByModule\n  }\n\n  #parseImportmapJson() {\n    const importmapScript = this.document.querySelector(\"script[type=importmap]\")\n    return JSON.parse(importmapScript.text).imports\n  }\n\n  async #reloadStimulusController(moduleName) {\n    log(`\\t${moduleName}`)\n\n    const controllerName = this.#extractControllerName(moduleName)\n    const path = cacheBustedUrl(this.#pathForModuleName(moduleName))\n\n    const module = await import(path)\n\n    this.#registerController(controllerName, module)\n  }\n\n  #unloadDeletedStimulusControllers() {\n    this.#controllersToUnload.forEach(controller => this.#deregisterController(controller.identifier))\n  }\n\n  get #controllersToUnload() {\n    if (this.#didChangeTriggerAReload) {\n      return []\n    } else {\n      return this.application.controllers.filter(controller => this.#changedControllerIdentifier === controller.identifier)\n    }\n  }\n\n  get #didChangeTriggerAReload() {\n    return this.#stimulusControllerPathsToReload.length > 0\n  }\n\n  #pathForModuleName(moduleName) {\n    return this.#stimulusPathsByModule[moduleName]\n  }\n\n  #extractControllerName(path) {\n    return path\n      .replace(/^\\/+/, \"\")\n      .replace(/^controllers\\//, \"\")\n      .replace(\"_controller\", \"\")\n      .replace(/\\//g, \"--\")\n      .replace(/_/g, \"-\")\n      .replace(/\\.js$/, \"\")\n  }\n\n  #registerController(name, module) {\n    this.application.unload(name)\n    this.application.register(name, module.default)\n  }\n\n  #deregisterController(name) {\n    log(`\\tRemoving controller ${name}`)\n    this.application.unload(name)\n  }\n}\n","import { Idiomorph } from \"idiomorph/dist/idiomorph.esm.js\"\nimport { reloadHtmlDocument } from \"../helpers.js\"\nimport { log } from \"../logger.js\"\nimport { StimulusReloader } from \"./stimulus_reloader.js\"\n\nexport class MorphHtmlReloader {\n  static async reload() {\n    return new MorphHtmlReloader().reload()\n  }\n\n  async reload() {\n    await this.#reloadHtml()\n    await this.#reloadStimulus()\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with morph...\")\n\n    const reloadedDocument = await reloadHtmlDocument()\n    this.#updateBody(reloadedDocument.body)\n    return reloadedDocument\n  }\n\n  #updateBody(newBody) {\n    Idiomorph.morph(document.body, newBody)\n  }\n\n  async #reloadStimulus() {\n    await StimulusReloader.reloadAll()\n  }\n}\n","import { log } from \"../logger.js\"\nimport { cacheBustedUrl, reloadHtmlDocument, pathWithoutAssetDigest } from \"../helpers.js\"\n\nexport class CssReloader {\n  static async reload(...params) {\n    return new CssReloader(...params).reload()\n  }\n\n  constructor(filePattern = /./) {\n    this.filePattern = filePattern\n  }\n\n  async reload() {\n    log(\"Reload css...\")\n    await Promise.all(await this.#reloadAllLinks())\n  }\n\n  async #reloadAllLinks() {\n    const cssLinks = await this.#loadNewCssLinks();\n    return cssLinks.map(link => this.#reloadLinkIfNeeded(link))\n  }\n\n  async #loadNewCssLinks() {\n    const reloadedDocument = await reloadHtmlDocument()\n    return Array.from(reloadedDocument.head.querySelectorAll(\"link[rel='stylesheet']\"))\n  }\n\n  #reloadLinkIfNeeded(link) {\n    if (this.#shouldReloadLink(link)) {\n      return this.#reloadLink(link)\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  #shouldReloadLink(link) {\n    return this.filePattern.test(link.getAttribute(\"href\"))\n  }\n\n  async #reloadLink(link) {\n    return new Promise(resolve => {\n      const href = link.getAttribute(\"href\")\n      const newLink = this.#findExistingLinkFor(link) || this.#appendNewLink(link)\n\n      newLink.setAttribute(\"href\", cacheBustedUrl(link.getAttribute(\"href\")))\n      newLink.onload = () => {\n        log(`\\t${href}`)\n        resolve()\n      }\n    })\n  }\n\n  #findExistingLinkFor(link) {\n    return this.#cssLinks.find(newLink => pathWithoutAssetDigest(link.href) === pathWithoutAssetDigest(newLink.href))\n  }\n\n  get #cssLinks() {\n    return Array.from(document.querySelectorAll(\"link[rel='stylesheet']\"))\n  }\n\n  #appendNewLink(link) {\n    document.head.append(link)\n    return link\n  }\n}\n","import { log, LOG_TAG } from \"../logger.js\"\n\nexport class ReplaceHtmlReloader {\n  static async reload() {\n    return new ReplaceHtmlReloader().reload()\n  }\n\n  async reload() {\n    if (!window.Turbo) {\n      console.log(LOG_TAG, \"Tried to replace the page with Turbo, but Turbo is not available on window.Turbo\");\n      return;\n    }\n    await this.#reloadHtml()\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with Turbo...\")\n\n    this.#keepScrollPosition()\n    await this.#visitCurrentPage()\n  }\n\n  #keepScrollPosition() {\n    document.addEventListener(\"turbo:before-render\", () => {\n      Turbo.navigator.currentVisit.scrolled = true\n    }, { once: true })\n  }\n\n  #visitCurrentPage() {\n    return new Promise(resolve => {\n      document.addEventListener(\"turbo:load\", () => resolve(document), { once: true })\n      window.Turbo.visit(window.location)\n    })\n  }\n}\n","import consumer from \"./consumer\"\nimport { assetNameFromPath } from \"../helpers.js\";\nimport { MorphHtmlReloader } from \"../reloaders/morph_html_reloader.js\";\nimport { CssReloader } from \"../reloaders/css_reloader.js\";\nimport { StimulusReloader } from \"../reloaders/stimulus_reloader.js\";\nimport { ReplaceHtmlReloader } from \"../reloaders/replace_html_reloader.js\";\n\nconsumer.subscriptions.create({ channel: \"Hotwire::Spark::Channel\" }, {\n  connected() {\n    document.body.setAttribute(\"data-hotwire-spark-ready\", \"\")\n  },\n\n  async received(message) {\n    try {\n      await this.dispatch(message)\n    } catch(error) {\n      console.log(`Error on ${message.action}`, error)\n    }\n  },\n\n  dispatch({ action, path }) {\n    switch(action) {\n      case \"reload_html\":\n        return this.reloadHtml()\n      case \"reload_css\":\n        return this.reloadCss(path)\n      case \"reload_stimulus\":\n        return this.reloadStimulus(path)\n      default:\n        throw new Error(`Unknown action: ${action}`)\n    }\n  },\n\n  reloadHtml() {\n    const htmlReloader = HotwireSpark.config.htmlReloadMethod == \"morph\" ? MorphHtmlReloader : ReplaceHtmlReloader\n    return htmlReloader.reload()\n  },\n\n  reloadCss(path) {\n    const fileName = assetNameFromPath(path)\n    return CssReloader.reload(new RegExp(fileName))\n  },\n\n  reloadStimulus(path) {\n    return StimulusReloader.reload(path)\n  }\n})\n\n","import config from \"./config.js\"\nimport \"./channels/monitoring_channel.js\"\n\nconst HotwireSpark = {\n  config\n}\n\nexport default HotwireSpark\n"],"names":["getConfigurationProperty","name","document","querySelector","content","config","loggingEnabled","htmlReloadMethod","cableServerPath","adapters","logger","console","undefined","WebSocket","log","messages","this","enabled","push","Date","now","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","staleThreshold","stop","stopPolling","removeEventListener","recordMessage","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","reconnectionBackoffRate","Math","pow","min","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","visibilityState","isOpen","INTERNAL","message_types","welcome","disconnect","ping","confirmation","rejection","disconnect_reasons","unauthorized","invalid_request","server_restart","remote","default_mount_path","protocols","supportedProtocols","slice","length","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","socketProtocols","subprotocols","uninstallEventHandlers","url","installEventHandlers","close","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","triedToReconnect","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","identifier","reason","reconnect","type","parse","reconnectAttempted","reload","confirmSubscription","notify","reconnected","reject","notifyAll","willAttemptReconnect","Subscription","params","mixin","object","properties","key","value","extend","perform","action","command","unsubscribe","remove","SubscriptionGuarantor","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","Subscriptions","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","Consumer","_url","test","a","createElement","href","replace","createWebSocketURL","connect","addSubProtocol","subprotocol","element","head","getAttribute","getConfig","createConsumer","pathWithoutAssetDigest","path","urlWithParams","urlString","URL","window","location","origin","Object","entries","forEach","_ref","searchParams","set","toString","cacheBustedUrl","async","reloadHtmlDocument","currentUrl","hotwire_spark","response","fetch","headers","Accept","ok","Error","status","fetchedHTML","text","DOMParser","parseFromString","Idiomorph","EMPTY_SET","Set","defaults","morphStyle","callbacks","beforeNodeAdded","noOp","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","style","shouldPreserve","elt","shouldReAppend","shouldRemove","afterHeadMorphed","morphNormalizedContent","oldNode","normalizedNewContent","ctx","block","oldHead","newHead","promises","handleHeadElement","Promise","all","then","assign","ignore","morphChildren","children","bestMatch","newContent","currentElement","firstChild","bestElement","score","newScore","scoreElement","nextSibling","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","stack","added","node","pop","parentElement","insertBefore","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","ignoreActiveValue","activeElement","ignoreActive","isSoftMatch","HTMLHeadElement","from","to","nodeType","fromAttributes","attributes","toAttributes","fromAttribute","ignoreAttribute","setAttribute","i","toAttribute","hasAttribute","removeAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","syncNodeFrom","replaceChild","newParent","oldParent","newChild","nextNewChild","insertionPoint","appendChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","attr","updateType","attributeName","ignoreUpdate","newHeadTag","currentHead","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","outerHTML","currentHeadElt","inNewContent","has","isReAppended","isPreserved","delete","values","newNode","newElt","createRange","createContextualFragment","src","resolve","promise","_resolve","removedElement","removeChild","kept","node1","node2","tagName","id","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","isIdInConsideration","deadIds","idIsWithinNode","targetNode","idMap","get","idSet","sourceSet","matchCount","populateIdMapForNode","nodeParent","idElements","querySelectorAll","current","createIdMap","oldContent","morph","Document","documentElement","parser","contentWithSvgsRemoved","match","generatedByIdiomorph","htmlElement","body","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","finalConfig","mergeDefaults","target","createMorphContext","LOG_TAG","_len","arguments","Array","_key","StimulusReloader","changedFilePath","reloadAll","Stimulus","controllers","controller","unload","register","application","reloadChangedStimulusControllers","unloadDeletedStimulusControllers","stimulusControllerPathsToReload","reloadStimulusController","moduleName","controllerPathsToReload","stimulusControllerPaths","shouldReloadController","keys","stimulusPathsByModule","endsWith","extractControllerName","changedControllerIdentifier","pathsByModule","parseImportmapJson","importmapScript","imports","controllerName","pathForModuleName","module","import","registerController","controllersToUnload","deregisterController","didChangeTriggerAReload","default","MorphHtmlReloader","reloadHtml","reloadStimulus","reloadedDocument","updateBody","newBody","CssReloader","filePattern","reloadAllLinks","loadNewCssLinks","link","reloadLinkIfNeeded","shouldReloadLink","reloadLink","newLink","findExistingLinkFor","appendNewLink","onload","cssLinks","find","ReplaceHtmlReloader","Turbo","keepScrollPosition","visitCurrentPage","navigator","currentVisit","scrolled","once","visit","connected","received","dispatch","reloadCss","HotwireSpark","fileName","split","assetNameFromPath","RegExp"],"mappings":"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","x_google_ignoreList":[1,4]}